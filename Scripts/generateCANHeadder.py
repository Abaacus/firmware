#!/usr/bin/env python
import logging, sys
logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

import cantools #$ If you get a failure on this line, you need to install the python package cantools: install pip and run 'pip install -r requirements.txt' (you may want to do this in a virtual env)
import os
import subprocess
import sys
import errno
import re
import operator

ReceivedSignalsArray = []
SentSignalsArray = []
DeclaredVariablesSignalsArray = []

def isSignalNameInArray(signal, array):
    for sig in array:
        if sig.name == signal.name:
            return True

    return False

def checkForDuplicateSignalReceive(signal):
    if isSignalNameInArray(signal, ReceivedSignalsArray):
        return True
    else:
        ReceivedSignalsArray.append(signal)
        return False

def checkForDuplicateSignalSend(signal):
    if isSignalNameInArray(signal, SentSignalsArray):
        return True
    else:
        SentSignalsArray.append(signal)
        return False

def checkForDuplicateSignalDeclaration(signal):
    if isSignalNameInArray(signal, DeclaredVariablesSignalsArray):
        return True
    else:
        DeclaredVariablesSignalsArray.append(signal)
        return False

def create_dir(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def fWrite(string, fileHandle):
    fileHandle.write(string + '\n')

def generateDepedencyFile(depFile, dbFile, headerFile, nodeName, boardType, ScriptsDir):
    with open(depFile, 'w+') as depFileHandle:
        fWrite('{headerFile}: {dir}/generateCANHeadder.py {dbFile}'.format(headerFile=headerFile, dbFile=dbFile, dir=ScriptsDir), depFileHandle)
        fWrite('	{dir}/generateCANHeadder.py {target} {boardType}'.format(target=nodeName, boardType=boardType, dir=ScriptsDir), depFileHandle)

def getGitCommit():
    label = '0df2a9a'
    gitClean = '0'

    try:
        if call(["git", "branch"], stderr=STDOUT, stdout=open(os.devnull, 'w')) != 0:
            label = subprocess.check_output(["git", "describe" ,"--tags", "--always"]).strip()
    except Exception:
        pass

    gitCommit = label

    return gitCommit

def writeHeaderFileIncludeGuardAndIncludes(boardType, headerFileHandle, nodeName, isChargerDBC=False):
    fWrite('// *** Autogenerated, Do not modify by hand', headerFileHandle)
    if isChargerDBC:
        includeDefineName = '__{nodeName}_charger_can_H'.format(nodeName=nodeName)
    else:
        includeDefineName = '__{nodeName}_can_H'.format(nodeName=nodeName)

    fWrite("#ifndef {includeDefineName}\n#define {includeDefineName}\n".format(includeDefineName=includeDefineName), headerFileHandle);
    if boardType == 'F7':
        fWrite("#include \"stm32f7xx_hal.h\"", headerFileHandle);
    else:
        fWrite("#include \"stm32f0xx_hal.h\"", headerFileHandle);

    fWrite("#include \"FreeRTOS.h\"", headerFileHandle);
    if not isChargerDBC:
        fWrite("#include \"canHeartbeat.h\"", headerFileHandle);
    fWrite("#include \"boardTypes.h\"", headerFileHandle);
    fWrite("", headerFileHandle)

def writeEndIncludeGuard(sourceFileHandle, headerFileHandle):
    fWrite('// END Autogenerated CAN header file. Do not modify by hand!!!', sourceFileHandle)
    fWrite('// END Autogenerated CAN header file. Do not modify by hand!!!', headerFileHandle)
    fWrite('#endif', headerFileHandle)

def getNodeAddressAndMessageGroupsAndWriteToHeaderFile(db, nodeName, headerFileHandle):
    nodeAddress = 0
    messageGroups = list()

    for node in db.nodes:
        if node.name == nodeName:
            nodeAddress = node.comment.split("_")[0]
            fWrite('#define CAN_NODE_ADDRESS ' + nodeAddress, headerFileHandle);
            for messageGroup in node.comment.split("_")[1].split(","):
                if messageGroup != "":
                    fWrite('#define CAN_NODE_MESSAGE_GROUP_'+messageGroup, headerFileHandle);
                    messageGroups.append(messageGroup)
    fWrite('', headerFileHandle);

    return messageGroups

def writeSourceFileIncludes(nodeName, sourceFileHandle, isChargerDBC=False):
    fWrite('//'+nodeName+' autogen can source', sourceFileHandle)
    fWrite('// *** Do not modify by hand', sourceFileHandle)
    if isChargerDBC:
        fWrite("#include \""+nodeName+"_charger_can.h\"", sourceFileHandle)
    else:
        fWrite("#include \""+nodeName+"_can.h\"", sourceFileHandle)
    fWrite('#include \"CRC_CALC.h\"', sourceFileHandle)
    fWrite('#include \"userCan.h\"', sourceFileHandle)
    fWrite('#include \"debug.h\"', sourceFileHandle)
    fWrite("#include \"{nodeName}_dtc.h\"".format(nodeName=nodeName), sourceFileHandle)

def writeDBCVersionAndGitCommitToSourceFile(gitCommit, db, sourceFileHandle, isChargerDBC=False):
    fWrite('//DBC version:', sourceFileHandle)
    if isChargerDBC:
        if not db.version:
            fWrite('int ChargerDBCVersion = 1;', sourceFileHandle)
        else:
            fWrite('int ChargerDBCVersion = '+db.version+';', sourceFileHandle)
    else:
        if not db.version:
            fWrite('int DBCVersion = 1;', sourceFileHandle)
        else:
            fWrite('int DBCVersion = '+db.version+';', sourceFileHandle)
        fWrite('char gitCommit[] = \"'+gitCommit+'\";', sourceFileHandle)
    fWrite('', sourceFileHandle)

def isRxMessage(msg, nodeName):
    for signal in msg.signals:
        if nodeName in signal.receivers:
            return True
    return False

def isProCanMessage(msg):
    for signal in msg.signals:
        if 'PRO_CAN' in signal.name:
            return True
    return False

def parseCanDB(db, nodeName):
    rxMessages = [msg for msg in db.messages if isRxMessage(msg, nodeName)]
    txMessages = [msg for msg in db.messages if nodeName in msg.senders]

    multiplexedRxMessages = [msg for msg in rxMessages if msg.is_multiplexed()]
    multiplexedTxMessages = [msg for msg in txMessages if msg.is_multiplexed()]

    dtcRxMessages = [msg for msg in rxMessages if 'DTC' in msg.name]
    dtcTxMessages = [msg for msg in txMessages if 'DTC' in msg.name]

    proCanRxMessages = [msg for msg in rxMessages if isProCanMessage(msg)]
    proCanTxMessages = [msg for msg in txMessages if isProCanMessage(msg)]

    heartbeatRxMessages = [msg for msg in rxMessages if 'Heartbeat' in msg.name]

    normalRxMessages = [msg for msg in rxMessages if msg not in multiplexedRxMessages and msg not in dtcRxMessages and msg not in proCanRxMessages and msg not in heartbeatRxMessages]
    normalTxMessages = [msg for msg in txMessages if msg not in multiplexedTxMessages and msg not in dtcTxMessages and msg not in proCanTxMessages]

    return (rxMessages, txMessages, normalRxMessages, normalTxMessages,
            multiplexedRxMessages, multiplexedTxMessages, dtcRxMessages, dtcTxMessages, proCanRxMessages, proCanTxMessages, heartbeatRxMessages)

def getStrippedSignalName(signalName):
    strippedSignalName = re.sub('\d+$', '', signalName)
    return strippedSignalName

def writeStructForMsg(msg, structName, fileHandle):
    msgSizeBits = msg.length * 8
    currentPos = 0
    startBits = list()
    multiplexedSignalCount = 1

    fWrite('struct {structName} {{'.format(structName=structName), fileHandle)

    if msg.comment == 'VERSION':
        fWrite('	int DBC : 8;', fileHandle)
        for i  in range(0,7):
            fWrite('	char git{i} : 8;'.format(i=str(i)), fileHandle)
    else:
        # Sort signals by start bit (maybe this is true already, but make sure)
        sortedSignals = sorted(msg.signals, key=operator.attrgetter('start'))
        for signal in sortedSignals:
            if not signal.start in startBits:
                signalName = signal.name
                if signal.start != currentPos:
                    fWrite('    uint64_t FILLER_{num} : {fillerSize};'.format(num=str(currentPos), fillerSize=str(signal.start - currentPos)), fileHandle)
                if signal.multiplexer_signal != None:
                    signalName = re.sub('\d+$', '', signalName) + str(multiplexedSignalCount)
                    multiplexedSignalCount += 1
                if signal.is_signed:
                    fWrite('    int64_t {signalName} : {size};'.format(signalName=signalName, size=signal.length), fileHandle)
                else:
                    fWrite('    uint64_t {signalName} : {size};'.format(signalName=signalName, size=signal.length), fileHandle)
                currentPos = signal.start + signal.length
                startBits.append(signal.start)

        if currentPos != msgSizeBits:
            fWrite('    uint64_t FILLER_END : {size};'.format(size=str(msgSizeBits - currentPos)), fileHandle)

    fWrite('};\n', fileHandle)

def writeSignalReceivedFunction(signal, fileHandle, variableName='', multiplexed=False, dtc=False):
    if checkForDuplicateSignalReceive(signal):
        return

    dataTypeOutput = 'float'
    if signal.scale == 1:
        if signal.is_signed:
            dataTypeOutput = 'int64_t'
        else:
            dataTypeOutput = 'uint64_t'

    functionTemplate = ''
    if multiplexed:
        functionTemplate = """void {signalName}Received(int index, {dataTypeInput} newValue)
{{
    {dataTypeOutput} outValue = newValue;
    outValue *= {scaler};
    outValue += {offset};
    {signalName}[index] = outValue;
}}\n"""
    elif dtc:
        functionTemplate = """int {signalName}Received({dataTypeInput} newValue)
{{
    {dataTypeOutput} outValue = newValue;
    outValue *= {scaler};
    outValue += {offset};
    return outValue;
}}\n"""
    else:
        functionTemplate = """void {signalName}Received({dataTypeInput} newValue)
{{
    {dataTypeOutput} outValue = newValue;
    outValue *= {scaler};
    outValue += {offset};
    {signalName} = outValue;
}}\n"""

    if signal.is_signed:
      dataTypeInput = 'int64_t'
    else:
      dataTypeInput = 'uint64_t'

    if variableName == '':
        variableName = signal.name
    function = functionTemplate.format(signalName=variableName, dataTypeInput=dataTypeInput, dataTypeOutput=dataTypeOutput, scaler=signal.scale, offset=signal.offset)
    fWrite(function, fileHandle)

def getSignalSendingFunctionName(signal, multiplexed):
    signalName = signal.name

    if multiplexed:
        signalName = getStrippedSignalName(signalName)

    return '{signalName}Sending'.format(signalName=signalName)

def writeSignalSendingFunction(signal, fileHandle, variableName='', multiplexed=False):
    if checkForDuplicateSignalSend(signal):
        return

    dataType = 'float'
    if signal.scale == 1:
        if signal.is_signed:
            dataType = 'int64_t'
        else:
            dataType = 'uint64_t'

    functionTemplate = ''
    if not multiplexed:
        functionTemplate = """{dataTypeReturn} {signalName}Sending()
{{
    {dataType} sendValue = {signalName};
    sendValue -= {offset};
    sendValue /= {scaler};
    return sendValue;
}}\n"""
    else:
        functionTemplate = """{dataTypeReturn} {signalName}Sending(int index)
{{
    {dataType} sendValue = {signalName}[index];
    sendValue -= {offset};
    sendValue /= {scaler};
    return sendValue;
}}\n"""

    if signal.is_signed:
      dataTypeReturn = 'int64_t'
    else:
      dataTypeReturn = 'uint64_t'

    if variableName == '':
        variableName = signal.name
    function = functionTemplate.format(signalName=variableName,dataType=dataType, dataTypeReturn=dataTypeReturn, scaler=signal.scale, offset=signal.offset)
    fWrite(function, fileHandle)

def writeValueTableEnum(signal, headerFileHandle):
    if signal.choices is not None:
        fWrite('enum {sigName}_Values {{'.format(sigName=signal.name), headerFileHandle)
        for Value, Name in signal.choices.items():
            fWrite('{sigName}_{Name} = {Value},'.format(sigName=signal.name, Name=Name, Value=Value), headerFileHandle)

        fWrite('};\n', headerFileHandle)

def writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle):
    if checkForDuplicateSignalDeclaration(signal):
        return

    writeValueTableEnum(signal, headerFileHandle)

    dataType = 'float'
    if signal.scale == 1:
        if signal.is_signed:
            dataType = 'int64_t'
        else:
            dataType = 'uint64_t'

    fWrite('volatile {dataType} {name};'.format(dataType=dataType, name=signal.name), sourceFileHandle)
    fWrite('extern volatile {dataType} {name};\n'.format(dataType=dataType, name=signal.name), headerFileHandle)

def getReceivedSignalsFromMessage(msg, nodeName):
    return [signal for signal in msg.signals if nodeName in signal.receivers]

def writeNormalRxMessages(nodeName, normalRxMessages, sourceFileHandle, headerFileHandle):
    for msg in normalRxMessages:
        fWrite('// Struct and signal receive functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)

        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
            writeSignalReceivedFunction(signal, sourceFileHandle)

def writeDTCRxMessages(nodeName, dtcRxMessages, sourceFileHandle, headerFileHandle):
    if len(dtcRxMessages) == 0:
        return

    # Create DTC Receive functions only once,
    # so just choose the first dtc message to base them on
    msg = dtcRxMessages[0]
    for signal in getReceivedSignalsFromMessage(msg, nodeName):
        fWrite('// signal received functions for multiplexed msg {}'.format(msg.name), sourceFileHandle)
        writeSignalReceivedFunction(signal, sourceFileHandle, dtc=True)



    # Now, create the struct
    for msg in dtcRxMessages:
        writeStructForMsg(msg, msg.name, sourceFileHandle)

        fWrite('typedef struct {msg.name}_unpacked {{'.format(**locals()), headerFileHandle)
        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            fWrite('    int {signal.name};'.format(**locals()), headerFileHandle)
        fWrite('}} {msg.name}_unpacked;'.format(**locals()), headerFileHandle)

def getMultiplexerId(signal):
    if not signal.is_multiplexer:
        return signal.multiplexer_ids[0]
    else:
        return 0

def getMultiplexedMsgInfo(msg):
    for multiplexer in msg.signal_tree[0]:
        signalGroupsList = msg.signal_tree[0][multiplexer]
        signalGroup = signalGroupsList[0]
        numSignalsPerMessage = len(signalGroup)
        signalName = signalGroup[0]
        strippedSignalName = getStrippedSignalName(signalName)

    sortedSignals = sorted(msg.signals, key=getMultiplexerId, reverse=True)

    max_id = sortedSignals[0].multiplexer_ids[0]
    numSignals = (max_id+1) * numSignalsPerMessage

    # find if the signals are signed, or unsigned
    is_signed = False
    sampleSignal = ''
    for signal in msg.signals:
        if not signal.is_multiplexer:
            is_signed = signal.is_signed
            sampleSignal = signal
            break

    dataType = 'float'
    if signal.scale == 1:
        if signal.is_signed:
            dataType = 'int64_t'
        else:
            dataType = 'uint64_t'

    return (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal)

def writeIndexToMuxFunction(msgName, numSignalsPerMessage, sourceFileHandle, headerFileHandle):
    prototypeTemplate = "uint8_t {name}IndexToMuxSelect( int index )"
    sourceTemplate = """{prototype} {{
    return (uint8_t) index / {numSignalsPerMessage};
}}
"""
    prototype = prototypeTemplate.format(name=msgName)
    fWrite("{prototype};".format(prototype=prototype), headerFileHandle)
    fWrite(sourceTemplate.format(prototype=prototype, numSignalsPerMessage=numSignalsPerMessage), sourceFileHandle)

def writeMuxToIndexFunction(msgName, numSignals, numSignalsPerMessage, sourceFileHandle, headerFileHandle):
    prototypeTemplate = "uint8_t {name}MuxSelectToIndex( int muxSelect, int offset )"
    sourceTemplate = """{prototype} {{
    int index =  muxSelect * {numSignalsPerMessage} + offset;
    if (index >= {numSignals}) {{
        index = {numSignals} - 1;
    }}

    return index;
}}
"""

    prototype = prototypeTemplate.format(name=msgName)
    fWrite("{prototype};".format(prototype=prototype), headerFileHandle)
    fWrite(sourceTemplate.format(prototype=prototype, numSignalsPerMessage=numSignalsPerMessage, numSignals=numSignals), sourceFileHandle)

def writeMultiplexedRxMessages(multiplexedRxMessages, sourceFileHandle, headerFileHandle):
    for msg in multiplexedRxMessages:
        fWrite('// Struct and signal receive functions for multiplexed msg {}'.format(msg.name), sourceFileHandle)

        (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal) = getMultiplexedMsgInfo(msg)

        fWrite('volatile {dataType} {name}[{count}];'.format(dataType=dataType, name=strippedSignalName, count=numSignals), sourceFileHandle)
        fWrite('extern volatile {dataType} {name}[{count}];'.format(dataType=dataType, name=strippedSignalName, count=numSignals), headerFileHandle)
        fWrite('#define {name}_COUNT ({count})'.format(name=strippedSignalName.upper(), count=numSignals), headerFileHandle)

        writeSignalReceivedFunction(sampleSignal, sourceFileHandle, variableName=strippedSignalName, multiplexed=True)
        # write the signal receive function for the multiplexer signal. Set multiplexed to false since this signal isn't multiplexed
        multiplexerSignal = [signal for signal in msg.signals if signal.name is sampleSignal.multiplexer_signal][0]
        writeSignalReceivedFunction(multiplexerSignal, sourceFileHandle, multiplexed=False)
        writeSignalVariableAndVariableDeclaration(multiplexerSignal, sourceFileHandle, headerFileHandle)

        writeStructForMsg(msg, msg.name, sourceFileHandle)
        writeMuxToIndexFunction(msg.name, numSignals, numSignalsPerMessage, sourceFileHandle, headerFileHandle)

def writeProCanRxMessages(nodeName, proCanRxMessages, sourceFileHandle, headerFileHandle):
    # For now, just ignore PRO_CAN signals on receive
    for msg in proCanRxMessages:
        fWrite('// Struct and signal receive functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)

        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            if not 'PRO_CAN' in signal.name:
                writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
                writeSignalReceivedFunction(signal, sourceFileHandle)

def writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, proCAN=False, multiplexed=False, numSignalsPerMessage=0, dtc=False, isChargerMsg=False):
    if multiplexed:
        multiplexIndexString = 'int index'
    else:
        multiplexIndexString = ''

    fWrite('int sendCAN_{name}({multiplexIndexString}) {{'.format(name=msg.name, multiplexIndexString=multiplexIndexString), sourceFileHandle)
    fWrite('int sendCAN_{name}({multiplexIndexString});'.format(name=msg.name, multiplexIndexString=multiplexIndexString), headerFileHandle)

    structInstanceName = 'new_{name}'.format(name=msg.name)
    fWrite('    struct {structName} {instanceName} = {{0}};'.format(structName=msg.name, instanceName=structInstanceName), sourceFileHandle)

    if proCAN:
        fWrite('    {structName}.PRO_CAN_COUNT = {msgName}_PRO_CAN_COUNT++;'.format(structName=structInstanceName, msgName=msg.name), sourceFileHandle)
        fWrite('    {msgName}_PRO_CAN_COUNT = {msgName}_PRO_CAN_COUNT % 16;'.format(msgName=msg.name), sourceFileHandle)
        fWrite('    {structName}.PRO_CAN_CRC = calculate_base_CRC((void *) &{structName})^{msgName}_PRO_CAN_SEED;\n'.format(structName=structInstanceName, msgName=msg.name), sourceFileHandle)

    for signal in msg.signals:
        if multiplexed:
            if signal.is_multiplexer:
                indexToMuxFunctionName = "{msgName}IndexToMuxSelect".format(msgName=msg.name)
                fWrite('    {structName}.{signalName} = {indexToMuxFunction}(index);'.format(structName=structInstanceName, signalName=signal.name, indexToMuxFunction=indexToMuxFunctionName), sourceFileHandle)
            else:
                # Signal will include ALL possible multiplexed signals, so just include up to the number of signals per message
                if numSignalsPerMessage > 0 or signal.multiplexer_signal is None:
                    sendFunctionName = getSignalSendingFunctionName(signal, multiplexed)
                    strippedSignalName = getStrippedSignalName(signal.name)
                    fWrite('    {structName}.{signalName}{signalNumber} = {sendFunction}(index+{offset});'.format(structName=structInstanceName, signalName=strippedSignalName, sendFunction=sendFunctionName, signalNumber=str(numSignalsPerMessage), offset=str(numSignalsPerMessage-1)), sourceFileHandle)
                    numSignalsPerMessage -= 1
        elif proCAN:
            if not 'PRO_CAN' in signal.name:
                sendFunctionName = getSignalSendingFunctionName(signal, multiplexed)
                fWrite('    {structName}.{signalName} = {sendFunction}();'.format(structName=structInstanceName, signalName=signal.name, sendFunction=sendFunctionName), sourceFileHandle)
        else:
            sendFunctionName = getSignalSendingFunctionName(signal, multiplexed)
            fWrite('    {structName}.{signalName} = {sendFunction}();'.format(structName=structInstanceName, signalName=signal.name, sendFunction=sendFunctionName), sourceFileHandle)

    sendFunctionName = ''
    if isChargerMsg:
        sendFunctionName = 'sendCanMessageCharger'
    else:
        sendFunctionName = 'sendCanMessage'

    if dtc:
        fWrite('    return {sendFunctionName}({id}, {len}, (uint8_t *)&{structName});'.format(sendFunctionName=sendFunctionName, id=msg.frame_id, len=msg.length, structName=structInstanceName), sourceFileHandle)
    else:
        fWrite('    return {sendFunctionName}({id}, {len}, (uint8_t *)&{structName});'.format(sendFunctionName=sendFunctionName, id=msg.frame_id, len=msg.length, structName=structInstanceName), sourceFileHandle)
    fWrite('}', sourceFileHandle)

def writeVersionSendFunction(msg, sourceFileHandle, headerFileHandle):
    fWrite('int sendCAN_{name}();\n'.format(name=msg.name), headerFileHandle)
    fWrite('int sendCAN_{name}() {{'.format(name=msg.name), sourceFileHandle)
    structInstanceName = 'new_{name}'.format(name=msg.name)
    fWrite('    struct {structName} {instanceName};'.format(structName=msg.name, instanceName=structInstanceName), sourceFileHandle)

    fWrite('    {structName}.DBC = DBCVersion;'.format(structName=structInstanceName), sourceFileHandle)
    for i in range(0,7):
        fWrite('    {structName}.git{i} = gitCommit[{i}];'.format(structName=structInstanceName, i=i), sourceFileHandle)

    fWrite('    return sendCanMessage({id}, {len}, (uint8_t *)&{structName});'.format(id=msg.frame_id, len=msg.length, structName=structInstanceName), sourceFileHandle)
    fWrite('}', sourceFileHandle)

def writeNormalTxMessages(normalTxMessages, sourceFileHandle, headerFileHandle, chargerMsg=False):
    for msg in normalTxMessages:
        fWrite('// Struct and signal send functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)

        if msg.comment == 'VERSION':
            # This is a message to send DBC and git commit, it is special
            writeVersionSendFunction(msg, sourceFileHandle, headerFileHandle)
        else:
            for signal in msg.signals:
                writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
                writeSignalSendingFunction(signal, sourceFileHandle)
            writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, isChargerMsg=chargerMsg)

def writeDTCTxMessages(dtcTxMessages, sourceFileHandle, headerFileHandle, chargerMsg=False):
    for msg in dtcTxMessages:
        fWrite('// Struct and signal send functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)

        for signal in msg.signals:
            writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
            writeSignalSendingFunction(signal, sourceFileHandle)
        writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, dtc=True, isChargerMsg=chargerMsg)

def writeMultiplexedTxMessages(multiplexedTxMessages, sourceFileHandle, headerFileHandle, chargerMsg=False):
    for msg in multiplexedTxMessages:
        fWrite('// Struct and signal receive functions for multiplexed msg {}'.format(msg.name), sourceFileHandle)

        (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal) = getMultiplexedMsgInfo(msg)

        fWrite('volatile {dataType} {name}[{count}];'.format(dataType=dataType, name=strippedSignalName, count=numSignals), sourceFileHandle)
        fWrite('#define {name}_COUNT ({count})'.format(name=strippedSignalName.upper(), count=numSignals), headerFileHandle)
        fWrite('extern volatile {dataType} {name}[{count}];\n'.format(dataType=dataType, name=strippedSignalName, count=numSignals), headerFileHandle)

        writeSignalSendingFunction(sampleSignal, sourceFileHandle, variableName=strippedSignalName, multiplexed=True)
        writeStructForMsg(msg, msg.name, sourceFileHandle)
        writeIndexToMuxFunction(msg.name, numSignalsPerMessage, sourceFileHandle, headerFileHandle)
        writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, multiplexed=True, numSignalsPerMessage=numSignalsPerMessage, isChargerMsg=chargerMsg)

def writeProCanSpecialVariables(msg, sourceFileHandle):
    fWrite('int {msgName}_PRO_CAN_SEED = 127;'.format(msgName=msg.name), sourceFileHandle)
    fWrite('int {msgName}_PRO_CAN_COUNT = 0;'.format(msgName=msg.name), sourceFileHandle)

def writeProCANTxMessages(proCanTxMessages, sourceFileHandle, headerFileHandle, chargerMsg=False):
    for msg in proCanTxMessages:
        fWrite('// Struct and signal send functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)

        writeProCanSpecialVariables(msg, sourceFileHandle)

        for signal in msg.signals:
            if not 'PRO_CAN' in signal.name:
                writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
                writeSignalSendingFunction(signal, sourceFileHandle)
        writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, proCAN=True, isChargerMsg=chargerMsg)


def writeParseCanRxMessageFunction(nodeName, normalRxMessages, dtcRxMessages, multiplexedRxMessages, proCanRxMessages, heartbeatRxMessages, sourceFileHandle, headerFileHandle, isChargerDBC=False):
    msgCallbackPrototypes = []
    if isChargerDBC:
        functionPrototype = 'int parseChargerCANData(int id, void *data)'
    else:
        functionPrototype = 'int parseCANData(int id, void *data)'

    fWrite('{};'.format(functionPrototype), headerFileHandle)
    fWrite('{} {{'.format(functionPrototype), sourceFileHandle)
    fWrite('    switch (id) {', sourceFileHandle)

    for msg in normalRxMessages:
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('        {', sourceFileHandle)
        fWrite('            struct {structName} *in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)
        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            fWrite('            {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)

        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)
        msgCallbackPrototypes.append('void {callback}()'.format(callback=callbackName))
        fWrite('            {callback}();'.format(callback=callbackName), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)
    for msg in heartbeatRxMessages:
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('        {', sourceFileHandle)
        txNode = msg.senders[0]
        fWrite('            heartbeatReceived(ID_{txNode});'.format(txNode=txNode), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    createdFatalCallback = False
    for msg in dtcRxMessages:
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('        {', sourceFileHandle)
        fWrite('            struct {structName} *in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)
        fWrite('            struct {structName}_unpacked newDtc;'.format(structName=msg.name), sourceFileHandle)
        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            fWrite('            newDtc.{signalName} = {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)

        fWrite('            DEBUG_PRINT_ISR("DTC ({name}). Code %d, Severity %d, Data %d\\n", newDtc.DTC_CODE, newDtc.DTC_Severity, newDtc.DTC_Data);'.format(name=msg.name), sourceFileHandle)  
        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)

        fatalCallbackName = 'DTC_Fatal_Callback'
        fatalCallbackPrototype = 'void {name}(BoardIDs board)'.format(name=fatalCallbackName)

        msgCallbackPrototypes.append('void {callback}(int DTC_CODE, int DTC_Severity, int DTC_Data)'.format(callback=callbackName))

        # only create one fatal callback
        if not createdFatalCallback:
            msgCallbackPrototypes.append('{callback}'.format(callback=fatalCallbackPrototype))
            createdFatalCallback = True

        fWrite('            if (newDtc.DTC_Severity == DTC_Severity_FATAL) {', sourceFileHandle)
        fWrite('                {fatalCallback}(ID_{nodeName});\n            }}'.format(fatalCallback=fatalCallbackName, nodeName=nodeName), sourceFileHandle)
        fWrite('            {callback}(newDtc.DTC_CODE, newDtc.DTC_Severity, newDtc.DTC_Data);'.format(callback=callbackName), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    for msg in proCanRxMessages:
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('        {', sourceFileHandle)
        fWrite('            struct {structName} *in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)
        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            if not 'PRO_CAN' in signal.name:
                fWrite('            {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)

        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)
        msgCallbackPrototypes.append('void {callback}()'.format(callback=callbackName))
        fWrite('            {callback}();'.format(callback=callbackName), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    for msg in multiplexedRxMessages:
        (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal) = getMultiplexedMsgInfo(msg)
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('        {', sourceFileHandle)
        fWrite('            struct {structName} *in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)

        muxToIndexFunction = '{name}MuxSelectToIndex'.format(name=msg.name)
        signal = msg.signals[0]
        muxSignalName = ''
        if signal.is_multiplexer:
            muxSignalName = signal.name
        else:
            muxSignalName = signal.multiplexer_signal.name

        for signal in getReceivedSignalsFromMessage(msg, nodeName):
            if signal.is_multiplexer:
                fWrite('            {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)
            else:
                # Signal will include ALL possible multiplexed signals, so just include up to the number of signals per message
                if numSignalsPerMessage > 0 or signal.multiplexer_signal is None:
                    strippedSignalName = getStrippedSignalName(signal.name)
                    fWrite('            {signalName}Received({mToI}(in_{structName}->{multiplexerName}, {signalNum}), in_{structName}->{signalName}{signalNum});'.format(signalName=strippedSignalName, structName=msg.name, mToI=muxToIndexFunction, multiplexerName=muxSignalName, signalNum=numSignalsPerMessage), sourceFileHandle)
                    numSignalsPerMessage -= 1

        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)
        msgCallbackPrototypes.append('void {callback}(int baseIndex, int signalsInMessage)'.format(callback=callbackName))
        fWrite('            {callback}({mToI}(in_{structName}->{multiplexerName}, 0), {numSignalsPerMessage});'.format(callback=callbackName, mToI=muxToIndexFunction, structName=msg.name, multiplexerName=muxSignalName, numSignalsPerMessage=numSignalsPerMessage), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    fWrite("""
        default:
        {
            return -1;
        }
    }

    return 0;
}""", sourceFileHandle)

    return msgCallbackPrototypes

def writeSetupCanFilters(boardType, messageGroups, sourceFileHandle, headerFileHandle, functionName='configCANFilters', isChargerDBC=False):
    fWrite('void {functionName}(CAN_HandleTypeDef* canHandle);'.format(functionName=functionName), headerFileHandle)
    fWrite('__weak void {functionName}(CAN_HandleTypeDef* canHandle)\n{{'.format(functionName=functionName), sourceFileHandle)
    if boardType == 'F0':
        fWrite('    CAN_FilterConfTypeDef  sFilterConfig;', sourceFileHandle)
    else: # F7
        fWrite('    CAN_FilterTypeDef  sFilterConfig;', sourceFileHandle)
    fWrite('    // Filter msgs to this nodes Id to fifo 0', sourceFileHandle)
    fWrite('    uint32_t filterID = CAN_NODE_ADDRESS<<8;', sourceFileHandle)
    fWrite('    filterID = filterID << 3; // Filter ID is left aligned to 32 bits', sourceFileHandle)
    fWrite('    uint32_t filterMask = 0xFF00;', sourceFileHandle)
    fWrite('    filterMask = filterMask << 3; // Filter masks are also left aligned to 32 bits', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdHigh = (filterID>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdLow = (filterID & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdHigh = (filterMask>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdLow = (filterMask & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterFIFOAssignment = 0;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterActivation = ENABLE;', sourceFileHandle)
    if boardType == 'F0':
        fWrite('    sFilterConfig.BankNumber = 0;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterNumber = 0;', sourceFileHandle)
    else:
        fWrite('    sFilterConfig.FilterBank = 0;', sourceFileHandle)
        # From the reference manual, it seems that setting SlaveStartFilterBank to 0 means all filters are used for the enabled CAN peripheral
        fWrite('    sFilterConfig.SlaveStartFilterBank = 0;\n', sourceFileHandle) # TODO: Verify this is the correct config
    fWrite('    if(HAL_CAN_ConfigFilter(canHandle, &sFilterConfig) != HAL_OK)', sourceFileHandle)
    fWrite('    {', sourceFileHandle)
    fWrite('      Error_Handler();', sourceFileHandle)
    fWrite('    }', sourceFileHandle)

    fWrite('\n    // Filter msgs to the broadcast Id to fifo 0', sourceFileHandle)
    if isChargerDBC:
        # Charger uses 0x50 as broadcast address
        fWrite('    filterID = 0x5000;', sourceFileHandle)
    else:
        fWrite('    filterID = 0xFF<<8;', sourceFileHandle)
    fWrite('    filterID = filterID << 3; // Filter ID is left aligned to 32 bits', sourceFileHandle)
    fWrite('    filterMask = 0xFF00;', sourceFileHandle)
    fWrite('    filterMask = filterMask << 3; // Filter masks are also left aligned to 32 bits', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdHigh = (filterID>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdLow = (filterID & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdHigh = (filterMask>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdLow = (filterMask & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterFIFOAssignment = 0;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterActivation = ENABLE;', sourceFileHandle)
    if boardType == 'F0':
        fWrite('    sFilterConfig.BankNumber = 1;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterNumber = 1;', sourceFileHandle)
    else:
        fWrite('    sFilterConfig.FilterBank = 1;', sourceFileHandle)
        # From the reference manual, it seems that setting SlaveStartFilterBank to 0 means all filters are used for the enabled CAN peripheral
        fWrite('    sFilterConfig.SlaveStartFilterBank = 0;\n', sourceFileHandle) # TODO: Verify this is the correct config
    fWrite('    if(HAL_CAN_ConfigFilter(canHandle, &sFilterConfig) != HAL_OK)', sourceFileHandle)
    fWrite('    {', sourceFileHandle)
    fWrite('      Error_Handler();', sourceFileHandle)
    fWrite('    }', sourceFileHandle)

    i = 1
    for messageGroup in messageGroups:
        i = i + 1
        fWrite('\n    // Filter msgs to the broadcast Id to fifo 0', sourceFileHandle)
        fWrite('    filterID = {msgGrp}<<12;'.format(msgGrp=messageGroup), sourceFileHandle)
        fWrite('    filterID = filterID << 3; // Filter ID is left aligned to 32 bits', sourceFileHandle)
        fWrite('    filterMask = 0xFF00;', sourceFileHandle)
        fWrite('    filterMask = filterMask << 3; // Filter masks are also left aligned to 32 bits', sourceFileHandle)
        fWrite('    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterIdHigh = (filterID>>16) & 0xFFFF;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterIdLow = (filterID & 0xFFFF);', sourceFileHandle)
        fWrite('    sFilterConfig.FilterMaskIdHigh = (filterMask>>16) & 0xFFFF;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterMaskIdLow = (filterMask & 0xFFFF);', sourceFileHandle)
        fWrite('    sFilterConfig.FilterFIFOAssignment = 0;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterActivation = ENABLE;', sourceFileHandle)
        if boardType == 'F0':
            fWrite('    sFilterConfig.BankNumber = {msgGrpNmbr};\n'.format(msgGrpNmbr=i), sourceFileHandle)
            fWrite('    sFilterConfig.FilterNumber = {msgGrpNmbr};\n'.format(msgGrpNmbr=i), sourceFileHandle)
        else:
            fWrite('    sFilterConfig.FilterBank = {msgGrpNmbr};\n'.format(msgGrpNmbr=i), sourceFileHandle)
            # From the reference manual, it seems that setting SlaveStartFilterBank to 0 means all filters are used for the enabled CAN peripheral
            fWrite('    sFilterConfig.SlaveStartFilterBank = 0;\n', sourceFileHandle) # TODO: Verify this is the correct config
        fWrite('    if(HAL_CAN_ConfigFilter(canHandle, &sFilterConfig) != HAL_OK)', sourceFileHandle)
        fWrite('    {', sourceFileHandle)
        fWrite('      Error_Handler();', sourceFileHandle)
        fWrite('    }', sourceFileHandle)

    fWrite('}', sourceFileHandle)

def writeInitFunction(sourceFileHandle, headerFileHandle):
    prototype = 'int init_can_driver()'
    fWrite('{prototype};'.format(prototype=prototype), headerFileHandle)
    fWrite('{prototype} {{'.format(prototype=prototype), sourceFileHandle)

    fWrite('    generate_CRC_lookup_table();', sourceFileHandle)

    fWrite('    return HAL_OK;', sourceFileHandle)
    fWrite('}', sourceFileHandle)

def writeMsgCallbacks(msgCallbackPrototypes, sourceFileHandle, headerFileHandle):
    for prototype in msgCallbackPrototypes:
        fWrite('{};\n'.format(prototype), headerFileHandle)
        fWrite('__weak {} {{}}\n'.format(prototype), sourceFileHandle)

def generateCANHeaderFromDB(dbFile, headerFileName, sourceFileName, nodeName, boardType, isChargerDBC=False):
    db = cantools.db.load_file(dbFile)

    gitCommit = getGitCommit()


    headerFileHandle = open(headerFileName, "w+")
    sourceFileHandle = open(sourceFileName, "w+")

    writeHeaderFileIncludeGuardAndIncludes(boardType, headerFileHandle, nodeName, isChargerDBC=isChargerDBC)

    if isChargerDBC:
        fWrite('#undef CAN_NODE_ADDRESS\n', sourceFileHandle)
        fWrite('#define CAN_NODE_ADDRESS 0xF4\n', sourceFileHandle)

    if (not isChargerDBC):
        messageGroups = getNodeAddressAndMessageGroupsAndWriteToHeaderFile(db, nodeName, headerFileHandle)
    else:
        messageGroups = []

    writeSourceFileIncludes(nodeName, sourceFileHandle, isChargerDBC=isChargerDBC)
    writeDBCVersionAndGitCommitToSourceFile(gitCommit, db, sourceFileHandle, isChargerDBC=isChargerDBC)


    (rxMessages, txMessages, normalRxMessages, normalTxMessages, multiplexedRxMessages,
     multiplexedTxMessages, dtcRxMessages, dtcTxMessages, proCanRxMessages, proCanTxMessages, heartbeatRxMessages) = parseCanDB(db, nodeName)

    # print normalRxMessages
    writeNormalRxMessages(nodeName, normalRxMessages, sourceFileHandle, headerFileHandle)

    if (not isChargerDBC):
        # print dtcRxMessages
        writeDTCRxMessages(nodeName, dtcRxMessages, sourceFileHandle, headerFileHandle)

        # print multiplexed Rx Messages
        writeMultiplexedRxMessages(multiplexedRxMessages, sourceFileHandle, headerFileHandle)

    # print normal Tx Messages
    writeNormalTxMessages(normalTxMessages, sourceFileHandle, headerFileHandle, chargerMsg=isChargerDBC)

    if (not isChargerDBC):
        # print dtc Tx Messages
        writeDTCTxMessages(dtcTxMessages, sourceFileHandle, headerFileHandle)

        # print multiplexed Tx Messages
        writeMultiplexedTxMessages(multiplexedTxMessages, sourceFileHandle, headerFileHandle)

        writeProCanRxMessages(nodeName, proCanRxMessages, sourceFileHandle, headerFileHandle)

        writeProCANTxMessages(proCanTxMessages, sourceFileHandle, headerFileHandle)

    # print parse can message function
    msgCallbackPrototypes = writeParseCanRxMessageFunction(nodeName, normalRxMessages, dtcRxMessages, multiplexedRxMessages, proCanRxMessages, heartbeatRxMessages, sourceFileHandle, headerFileHandle, isChargerDBC=isChargerDBC)

    if isChargerDBC:
        writeSetupCanFilters(boardType, messageGroups, sourceFileHandle, headerFileHandle, functionName='configCANFiltersCharger', isChargerDBC=True)
    else:
        writeSetupCanFilters(boardType, messageGroups, sourceFileHandle, headerFileHandle)

    if not isChargerDBC:
        writeInitFunction(sourceFileHandle, headerFileHandle)

    writeMsgCallbacks(msgCallbackPrototypes, sourceFileHandle, headerFileHandle)

    writeEndIncludeGuard(sourceFileHandle, headerFileHandle)

    headerFileHandle.close()
    sourceFileHandle.close()

def main(argv):
    if argv and len(argv) == 2:
        nodeName = argv[0]
        boardType = argv[1] # F0 or F7
    else:
        print('Error: no target specified or no boardtype specified')
        sys.exit(1)

    print 'Generating CAN source and header files for Board: {nodeName}, Type: {boardType}'.format(nodeName=nodeName, boardType=boardType)

    if not (boardType == 'F0' or boardType == 'F7'):
        print("ERROR: Specifiy either F0 or F7 for boardtype")
        sys.exit(1)

    commonDir = 'common-all'
    genDir = 'Gen'

    genIncDir = os.path.join(genDir, 'Inc')
    genSrcDir = os.path.join(genDir, 'Src')
    create_dir(genIncDir) # Create genIncDir if it doesn't already exist
    create_dir(genSrcDir) # Create genSrcDir if it doesn't already exist

    ScriptsDir = os.path.join(commonDir, 'Scripts')

    depFile = os.path.join(genDir, 'canGen.d')

    dataDir = os.path.join(commonDir, 'Data')
    mainDbFile = os.path.join(dataDir, '2018CAR.dbc')

    headerFile = os.path.join(genIncDir, nodeName + '_can.h')
    sourceFile = os.path.join(genSrcDir, nodeName + '_can.c')

    generateCANHeaderFromDB(mainDbFile, headerFile, sourceFile, nodeName, boardType)

    if (nodeName == 'BMU'):
        chargerDbFile = os.path.join(dataDir, 'ChargerMessages.dbc')

        chargerHeaderFile = os.path.join(genIncDir, nodeName + '_charger_can.h')
        chargerSourceFile = os.path.join(genSrcDir, nodeName + '_charger_can.c')

        generateCANHeaderFromDB(chargerDbFile, chargerHeaderFile, chargerSourceFile, nodeName, boardType, isChargerDBC=True)


if __name__ == '__main__':
    main(sys.argv[1:])
