#!/usr/bin/env python
import logging, sys
logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

import cantools #$ If you get a failure on this line, you need to install the python package cantools: install pip and run 'pip install -r requirements.txt' (you may want to do this in a virtual env)
import os
from pprint import pprint
import subprocess
import sys
import errno
import re
import operator

def create_dir(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def fWrite(string, fileHandle):
    fileHandle.write(string + '\n')

def generateDepedencyFile(headerFile, target):
    with open(depFile, 'w+') as depFileHandle:
        fWrite('{headerFile}: {dir}/generateCANHeadder.py {dbFile}'.format(headerFile=headerFile, dbFile=dbFile, dir=ScriptsDir), depFileHandle)
        fWrite('	{dir}/generateCANHeadder.py {target} {boardType}'.format(target=target, boardType=boardType, dir=ScriptsDir), depFileHandle)

def getGitCommit():
    label = '0df2a9a'
    gitClean = '0'

    try:
        if call(["git", "branch"], stderr=STDOUT, stdout=open(os.devnull, 'w')) != 0:
            label = subprocess.check_output(["git", "describe" ,"--tags", "--always"]).strip()
    except Exception:
        pass

    gitCommit = label

    return gitCommit

def writeHeaderFileIncludeGuardAndIncludes(boardType, headerFileHandle, nodeName):
    fWrite('// *** Autogenerated, Do not modify by hand', headerFileHandle)
    fWrite("#ifndef __"+nodeName+"_can_H\n#define __"+nodeName+"_can_H\n", headerFileHandle);
    if boardType == 'F7':
        fWrite("#include \"stm32f7xx_hal.h\"", headerFileHandle);
    else:
        fWrite("#include \"stm32f0xx_hal.h\"", headerFileHandle);

    fWrite("#include \"FreeRTOS.h\"", headerFileHandle);
    fWrite("#include \"queue.h\"", headerFileHandle);
    fWrite("", headerFileHandle)

def getNodeAddressAndMessageGroupsAndWriteToHeaderFile(db, nodeName, headerFileHandle):
    nodeAddress = 0
    messageGroups = list()

    for node in db.nodes:
        if node.name == nodeName:
            nodeAddress = node.comment.split("_")[0]
            fWrite('#define CAN_NODE_ADDRESS ' + nodeAddress, headerFileHandle);
            for messageGroup in node.comment.split("_")[1].split(","):
                if messageGroup != "":
                    fWrite('#define CAN_NODE_MESSAGE_GROUP_'+messageGroup, headerFileHandle);
                    messageGroups.append(messageGroup)
    fWrite('', headerFileHandle);

    return messageGroups

def writeSourceFileIncludes(nodeName, sourceFileHandle):
    fWrite('//'+nodeName+' autogen can source', sourceFileHandle)
    fWrite('// *** Do not modify by hand', sourceFileHandle)
    fWrite("#include \""+nodeName+"_can.h\"", sourceFileHandle)
    fWrite('#include \"CRC_CALC.h\"', sourceFileHandle)
    fWrite('#include \"userCan.h\"', sourceFileHandle)

def writeDBCVersionAndGitCommitToSourceFile(gitCommit, db, sourceFileHandle):
    fWrite('//DBC version:', sourceFileHandle)
    fWrite('int DBCVersion = '+db.version+';', sourceFileHandle)
    fWrite('char gitCommit[] = \"'+gitCommit+'\";', sourceFileHandle)
    fWrite('', sourceFileHandle)

def isRxMessage(msg, nodeName):
    for signal in msg.signals:
        if nodeName in signal.receivers:
            return True
    return False

def parseCanDB(db, nodeName):
    rxMessages = [msg for msg in db.messages if isRxMessage(msg, nodeName)]
    txMessages = [msg for msg in db.messages if nodeName in msg.senders]

    multiplexedRxMessages = [msg for msg in rxMessages if msg.is_multiplexed()]
    multiplexedTxMessages = [msg for msg in txMessages if msg.is_multiplexed()]
    dtcRxMessages = [msg for msg in rxMessages if 'DTC' in msg.name]
    dtcTxMessages = [msg for msg in txMessages if 'DTC' in msg.name]

    normalRxMessages = [msg for msg in rxMessages if msg not in multiplexedRxMessages and msg not in dtcRxMessages]
    normalTxMessages = [msg for msg in txMessages if msg not in multiplexedTxMessages and msg not in dtcTxMessages]

    return (rxMessages, txMessages, normalRxMessages, normalTxMessages,
            multiplexedRxMessages, multiplexedTxMessages, dtcRxMessages, dtcTxMessages)

def getStrippedSignalName(signalName):
    strippedSignalName = re.sub('\d+$', '', signalName)
    return strippedSignalName

def writeStructForMsg(msg, structName, fileHandle):
    msgSizeBits = msg.length * 8
    currentPos = 0
    startBits = list()
    multiplexedSignalCount = 1

    fWrite('struct {structName} {{'.format(structName=structName), fileHandle)

    if msg.comment == 'VERSION':
        fWrite('	int DBC : 8;', fileHandle)
        for i  in range(0,7):
            fWrite('	char git{i} : 8;'.format(i=str(i)), fileHandle)
    else:
        # Sort signals by start bit (maybe this is true already, but make sure)
        sortedSignals = sorted(msg.signals, key=operator.attrgetter('start'))
        for signal in sortedSignals:
            if not signal.start in startBits:
                signalName = signal.name
                if signal.start != currentPos:
                    fWrite('    uint64_t FILLER_{num} : {fillerSize};'.format(num=str(currentPos), fillerSize=str(signal.start - currentPos)), fileHandle)
                if signal.multiplexer_signal != None:
                    signalName = re.sub('\d+$', '', signalName) + str(multiplexedSignalCount)
                    multiplexedSignalCount += 1
                if signal.is_signed:
                    fWrite('    int64_t {signalName} : {size};'.format(signalName=signalName, size=signal.length), fileHandle)
                else:
                    fWrite('    uint64_t {signalName} : {size};'.format(signalName=signalName, size=signal.length), fileHandle)
                currentPos = signal.start + signal.length
                startBits.append(signal.start)

        if currentPos != msgSizeBits:
            fWrite('    uint64_t FILLER_END : {size};'.format(size=str(msgSizeBits - currentPos)), fileHandle)

    fWrite('};\n', fileHandle)

def writeSignalReceivedFunction(signal, fileHandle, variableName='', multiplexed=False, dtc=False):
    functionTemplate = ''
    if multiplexed:
        functionTemplate = """void {signalName}Received(int index, {dataType} newValue)
{{
    float floatValue = (float)newValue;
    floatValue *= {scaler};
    floatValue += {offset};
    {signalName}[index] = floatValue;
}}\n"""
    elif dtc:
        functionTemplate = """int {signalName}Received({dataType} newValue)
{{
    float floatValue = (float)newValue;
    floatValue *= {scaler};
    floatValue += {offset};
    return floatValue;
}}\n"""
    else:
        functionTemplate = """void {signalName}Received({dataType} newValue)
{{
    float floatValue = (float)newValue;
    floatValue *= {scaler};
    floatValue += {offset};
    {signalName} = floatValue;
}}\n"""

    if signal.is_signed:
      dataType = 'int64_t'
    else:
      dataType = 'uint64_t'

    if variableName == '':
        variableName = signal.name
    function = functionTemplate.format(signalName=variableName,dataType=dataType, scaler=signal.scale, offset=signal.offset)
    fWrite(function, fileHandle)

def getSignalSendingFunctionName(signal, multiplexed):
    signalName = signal.name

    if multiplexed:
        signalName = getStrippedSignalName(signalName)

    return '{signalName}Sending'.format(signalName=signalName)

def writeSignalSendingFunction(signal, fileHandle, variableName='', multiplexed=False):
    functionTemplate = ''
    if not multiplexed:
        functionTemplate = """{dataType} {signalName}Sending()
{{
    float sendValue = {signalName};
    sendValue -= {offset};
    sendValue /= {scaler};
    return sendValue;
}}\n"""
    else:
        functionTemplate = """{dataType} {signalName}Sending(int index)
{{
    float sendValue = {signalName}[index];
    sendValue -= {offset};
    sendValue /= {scaler};
    return sendValue;
}}\n"""

    if signal.is_signed:
      dataType = 'int64_t'
    else:
      dataType = 'uint64_t'

    if variableName == '':
        variableName = signal.name
    function = functionTemplate.format(signalName=variableName,dataType=dataType, scaler=signal.scale, offset=signal.offset)
    fWrite(function, fileHandle)

def writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle):
    if signal.is_signed:
      dataType = 'int64_t'
    else:
      dataType = 'uint64_t'

    fWrite('volatile {dataType} {name};'.format(dataType=dataType, name=signal.name), sourceFileHandle)
    fWrite('extern {dataType} {name};\n'.format(dataType=dataType, name=signal.name), headerFileHandle)


def writeNormalRxMessages(normalRxMessages, sourceFileHandle, headerFileHandle):
    for msg in normalRxMessages:
        fWrite('// Struct and signal receive functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)
        for signal in msg.signals:
            writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
            writeSignalReceivedFunction(signal, sourceFileHandle)

def writeDTCRxMessages(dtcRxMessages, sourceFileHandle, headerFileHandle):
    queueInitStrings = list()
    dtcQueueSize = 5

    if len(dtcRxMessages) == 0:
        return

    # Create DTC Receive functions and packed struct only once,
    # so just choose the first dtc message to base them on
    msg = dtcRxMessages[0]
    for signal in msg.signals:
        fWrite('// signal received functions for multiplexed msg {}'.format(msg.name), sourceFileHandle)
        writeSignalReceivedFunction(signal, sourceFileHandle, dtc=True)

    writeStructForMsg(msg, msg.name, sourceFileHandle)


    # Now, create the struct and queue for all messages
    for msg in dtcRxMessages:
        fWrite('typedef struct {msg.name}_unpacked {{'.format(**locals()), headerFileHandle)
        for signal in msg.signals:
            fWrite('    int {signal.name};'.format(**locals()), headerFileHandle)
        fWrite('}} {msg.name}_unpacked;'.format(**locals()), headerFileHandle)

        # create Queue to store received DTC messages
        queueName = 'queue{msg.name}'.format(**locals())
        fWrite('extern QueueHandle_t {queueName};\n'.format(**locals()), headerFileHandle)
        fWrite('QueueHandle_t {queueName};'.format(**locals()), sourceFileHandle)
        queueInitStrings.append('{queueName} = xQueueCreate({dtcQueueSize}, sizeof({messageName}_unpacked)); if ({queueName} == NULL) return HAL_ERROR;'.format(queueName=queueName, messageName=msg.name, dtcQueueSize=str(dtcQueueSize)))

    return queueInitStrings


def getMultiplexerId(signal):
    if not signal.is_multiplexer:
        return signal.multiplexer_ids[0]
    else:
        return 0

def getMultiplexedMsgInfo(msg):
    for multiplexer in msg.signal_tree[0]:
        signalGroupsList = msg.signal_tree[0][multiplexer]
        signalGroup = signalGroupsList[0]
        numSignalsPerMessage = len(signalGroup)
        signalName = signalGroup[0]
        strippedSignalName = getStrippedSignalName(signalName)

    sortedSignals = sorted(msg.signals, key=getMultiplexerId, reverse=True)

    max_id = sortedSignals[0].multiplexer_ids[0]
    numSignals = (max_id+1) * numSignalsPerMessage

    # find if the signals are signed, or unsigned
    is_signed = False
    sampleSignal = ''
    for signal in msg.signals:
        if not signal.is_multiplexer:
            is_signed = signal.is_signed
            sampleSignal = signal
            break

    if is_signed:
        dataType = 'int64_t'
    else:
        dataType = 'uint64_t'

    return (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal)

def writeIndexToMuxFunction(msgName, numSignalsPerMessage, sourceFileHandle, headerFileHandle):
    prototypeTemplate = "uint8_t {name}IndexToMuxSelect( int index )"
    sourceTemplate = """{prototype} {{
    return (uint8_t) index / {numSignalsPerMessage};
}}
"""
    prototype = prototypeTemplate.format(name=msgName)
    fWrite("{prototype};".format(prototype=prototype), headerFileHandle)
    fWrite(sourceTemplate.format(prototype=prototype, numSignalsPerMessage=numSignalsPerMessage), sourceFileHandle)

def writeMuxToIndexFunction(msgName, numSignals, numSignalsPerMessage, sourceFileHandle, headerFileHandle):
    prototypeTemplate = "uint8_t {name}MuxSelectToIndex( int muxSelect, int offset )"
    sourceTemplate = """{prototype} {{
    int index =  muxSelect * {numSignalsPerMessage} + offset;
    if (index >= {numSignals}) {{
        index = {numSignals} - 1;
    }}

    return index;
}}
"""

    prototype = prototypeTemplate.format(name=msgName)
    fWrite("{prototype};".format(prototype=prototype), headerFileHandle)
    fWrite(sourceTemplate.format(prototype=prototype, numSignalsPerMessage=numSignalsPerMessage, numSignals=numSignals), sourceFileHandle)

def writeMultiplexedRxMessages(multiplexedRxMessages, sourceFileHandle, headerFileHandle):
    print 'Multiplexed messages'
    print multiplexedRxMessages

    for msg in multiplexedRxMessages:
        fWrite('// Struct and signal receive functions for multiplexed msg {}'.format(msg.name), sourceFileHandle)

        (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal) = getMultiplexedMsgInfo(msg)

        fWrite('volatile {dataType} {name}[{count}];'.format(dataType=dataType, name=strippedSignalName, count=numSignals), sourceFileHandle)
        fWrite('extern {dataType} {name}[{count}];'.format(dataType=dataType, name=strippedSignalName, count=numSignals), headerFileHandle)
        fWrite('const int {name}_COUNT = {count};\n'.format(name=strippedSignalName.upper(), count=numSignals), headerFileHandle)

        writeSignalReceivedFunction(sampleSignal, sourceFileHandle, variableName=strippedSignalName, multiplexed=True)
        writeStructForMsg(msg, msg.name, sourceFileHandle)
        writeMuxToIndexFunction(msg.name, numSignals, numSignalsPerMessage, sourceFileHandle, headerFileHandle)

def writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, multiplexed=False, numSignalsPerMessage=0):
    if multiplexed:
        multiplexIndexString = 'int index'
    else:
        multiplexIndexString = ''

    fWrite('int sendCAN_{name}({multiplexIndexString}) {{'.format(name=msg.name, multiplexIndexString=multiplexIndexString), sourceFileHandle)
    fWrite('int sendCAN_{name}({multiplexIndexString});'.format(name=msg.name, multiplexIndexString=multiplexIndexString), headerFileHandle)

    structInstanceName = 'new_{name}'.format(name=msg.name)
    fWrite('    struct {name} {name};'.format(name=structInstanceName), sourceFileHandle)

    for signal in msg.signals:
        if multiplexed:
            if signal.is_multiplexer:
                indexToMuxFunctionName = "{msgName}IndexToMuxSelect".format(msgName=msg.name)
                fWrite('    {structName}.{signalName} = {indexToMuxFunction}(index);'.format(structName=structInstanceName, signalName=signal.name, indexToMuxFunction=indexToMuxFunctionName), sourceFileHandle)
            else:
                # Signal will include ALL possible multiplexed signals, so just include up to the number of signals per message
                if numSignalsPerMessage > 0 or signal.multiplexer_signal is None:
                    sendFunctionName = getSignalSendingFunctionName(signal, multiplexed)
                    strippedSignalName = getStrippedSignalName(signal.name)
                    fWrite('    {structName}.{signalName}{signalNumber} = {sendFunction}(index);'.format(structName=structInstanceName, signalName=strippedSignalName, sendFunction=sendFunctionName, signalNumber=str(numSignalsPerMessage)), sourceFileHandle)
                    numSignalsPerMessage -= 1
        else:
            sendFunctionName = getSignalSendingFunctionName(signal, multiplexed)
            fWrite('    {structName}.{signalName} = {sendFunction}();'.format(structName=structInstanceName, signalName=signal.name, sendFunction=sendFunctionName), sourceFileHandle)

    fWrite('    return sendCanMessage({id}, {len}, (uint8_t *){structName});'.format(id=msg.frame_id, len=msg.length, structName=structInstanceName), sourceFileHandle)
    fWrite('}', sourceFileHandle)

def writeNormalTxMessages(normalTxMessages, sourceFileHandle, headerFileHandle):
    for msg in normalTxMessages:
        fWrite('// Struct and signal send functions for msg {}'.format(msg.name), sourceFileHandle)
        writeStructForMsg(msg, msg.name, sourceFileHandle)
        for signal in msg.signals:
            writeSignalVariableAndVariableDeclaration(signal, sourceFileHandle, headerFileHandle)
            writeSignalSendingFunction(signal, sourceFileHandle)
        writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle)

def writeDTCTxMessages(dtcTxMessages, sourceFileHandle, headerFileHandle):
    # handled the same as normal Tx messages
    writeNormalTxMessages(dtcTxMessages, sourceFileHandle, headerFileHandle)

def writeMultiplexedTxMessages(multiplexedTxMessages, sourceFileHandle, headerFileHandle):
    print 'Multiplexed messages'
    print multiplexedTxMessages

    for msg in multiplexedTxMessages:
        fWrite('// Struct and signal receive functions for multiplexed msg {}'.format(msg.name), sourceFileHandle)

        (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal) = getMultiplexedMsgInfo(msg)

        fWrite('volatile {dataType} {name}[{count}];'.format(dataType=dataType, name=strippedSignalName, count=numSignals), sourceFileHandle)
        fWrite('const int {name}_COUNT = {count};'.format(name=strippedSignalName.upper(), count=numSignals), headerFileHandle)
        fWrite('extern {dataType} {name}[{count}];\n'.format(dataType=dataType, name=strippedSignalName, count=numSignals), headerFileHandle)

        writeSignalSendingFunction(sampleSignal, sourceFileHandle, variableName=strippedSignalName, multiplexed=True)
        writeStructForMsg(msg, msg.name, sourceFileHandle)
        writeIndexToMuxFunction(msg.name, numSignalsPerMessage, sourceFileHandle, headerFileHandle)
        writeMessageSendFunction(msg, sourceFileHandle, headerFileHandle, multiplexed=True, numSignalsPerMessage=numSignalsPerMessage)

def writeParseCanRxMessageFunction(normalRxMessages, dtcRxMessages, multiplexedRxMessages, sourceFileHandle, headerFileHandle):
    functionPrototype = 'int parseCANData(int id, void *data)'
    fWrite('{};'.format(functionPrototype), headerFileHandle)
    fWrite('{} {{'.format(functionPrototype), sourceFileHandle)
    fWrite('    switch (id) {', sourceFileHandle)

    for msg in normalRxMessages:
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('            struct {structName} in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)
        for signal in msg.signals:
            fWrite('            {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)

        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)
        fWrite('            {callback}();'.format(callback=callbackName), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    for msg in dtcRxMessages:
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('            struct {structName} in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)
        fWrite('            struct {structName}_unpacked newDtc;'.format(structName=msg.name), sourceFileHandle)
        for signal in msg.signals:
            fWrite('            newDtc.{signalName} = {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)

        fWrite('            xQueueSendFromISR(queue{msgName}, &newDTC, NULL);'.format(msgName=msg.name), sourceFileHandle)
        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)
        fWrite('            {callback}();'.format(callback=callbackName), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    for msg in multiplexedRxMessages:
        (numSignalsPerMessage, strippedSignalName, numSignals, dataType, sampleSignal) = getMultiplexedMsgInfo(msg)
        fWrite('        case {id}:'.format(id=msg.frame_id), sourceFileHandle)
        fWrite('            struct {structName} in_{structName} = data;'.format(structName=msg.name), sourceFileHandle)

        muxToIndexFunction = '{name}MuxSelectToIndex'.format(name=msg.name)
        signal = msg.signals[0]
        muxSignalName = ''
        if signal.is_multiplexer:
            muxSignalName = signal.name
        else:
            muxSignalName = signal.multiplexer_signal.name

        for signal in msg.signals:
            if signal.is_multiplexer:
                fWrite('            {signalName}Received(in_{structName}->{signalName});'.format(signalName=signal.name, structName=msg.name), sourceFileHandle)
            else:
                # Signal will include ALL possible multiplexed signals, so just include up to the number of signals per message
                if numSignalsPerMessage > 0 or signal.multiplexer_signal is None:
                    strippedSignalName = getStrippedSignalName(signal.name)
                    fWrite('            {signalName}Received({mToI}(in_{structName}->{multiplexerName}, in_{structName}->{signalName}{signalNum});'.format(signalName=strippedSignalName, structName=msg.name, mToI=muxToIndexFunction, multiplexerName=muxSignalName, signalNum=numSignalsPerMessage), sourceFileHandle)
                    numSignalsPerMessage -= 1

        callbackName = 'CAN_Msg_{msgName}_Callback'.format(msgName=msg.name)
        fWrite('            {callback}();'.format(callback=callbackName), sourceFileHandle)
        fWrite('            break;\n        }', sourceFileHandle)

    fWrite("""
        default:
        {
            return -1
        }
    }

    return 0;
}""", sourceFileHandle)

def writeSetupCanFilters(boardType, messageGroups, sourceFileHandle, headerFileHandle):
    fWrite('void configCANFilters(CAN_HandleTypeDef* canHandle);', headerFileHandle)
    fWrite('__weak void configCANFilters(CAN_HandleTypeDef* canHandle)\n{', sourceFileHandle)
    if boardType == 'F0':
        fWrite('    CAN_FilterConfTypeDef  sFilterConfig;', sourceFileHandle)
    else: # F7
        fWrite('    CAN_FilterTypeDef  sFilterConfig;', sourceFileHandle)
    fWrite('    // Filter msgs to this nodes Id to fifo 0', sourceFileHandle)
    fWrite('    uint32_t filterID = CAN_NODE_ADDRESS<<8;', sourceFileHandle)
    fWrite('    filterID = filterID << 3; // Filter ID is left aligned to 32 bits', sourceFileHandle)
    fWrite('    uint32_t filterMask = 0xFF00;', sourceFileHandle)
    fWrite('    filterMask = filterMask << 3; // Filter masks are also left aligned to 32 bits', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdHigh = (filterID>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdLow = (filterID & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdHigh = (filterMask>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdLow = (filterMask & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterFIFOAssignment = 0;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterActivation = ENABLE;', sourceFileHandle)
    if boardType == 'F0':
        fWrite('    sFilterConfig.BankNumber = 0;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterNumber = 0;', sourceFileHandle)
    else:
        fWrite('    sFilterConfig.FilterBank = 0;', sourceFileHandle)
        # From the reference manual, it seems that setting SlaveStartFilterBank to 0 means all filters are used for the enabled CAN peripheral
        fWrite('    sFilterConfig.SlaveStartFilterBank = 0;\n', sourceFileHandle) # TODO: Verify this is the correct config
    fWrite('    if(HAL_CAN_ConfigFilter(canHandle, &sFilterConfig) != HAL_OK)', sourceFileHandle)
    fWrite('    {', sourceFileHandle)
    fWrite('      Error_Handler();', sourceFileHandle)
    fWrite('    }', sourceFileHandle)

    fWrite('\n    // Filter msgs to the broadcast Id to fifo 0', sourceFileHandle)
    fWrite('    filterID = 0xFF<<8;', sourceFileHandle)
    fWrite('    filterID = filterID << 3; // Filter ID is left aligned to 32 bits', sourceFileHandle)
    fWrite('    filterMask = 0xFF00;', sourceFileHandle)
    fWrite('    filterMask = filterMask << 3; // Filter masks are also left aligned to 32 bits', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdHigh = (filterID>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterIdLow = (filterID & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdHigh = (filterMask>>16) & 0xFFFF;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterMaskIdLow = (filterMask & 0xFFFF);', sourceFileHandle)
    fWrite('    sFilterConfig.FilterFIFOAssignment = 0;', sourceFileHandle)
    fWrite('    sFilterConfig.FilterActivation = ENABLE;', sourceFileHandle)
    if boardType == 'F0':
        fWrite('    sFilterConfig.BankNumber = 1;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterNumber = 1;', sourceFileHandle)
    else:
        fWrite('    sFilterConfig.FilterBank = 1;', sourceFileHandle)
        # From the reference manual, it seems that setting SlaveStartFilterBank to 0 means all filters are used for the enabled CAN peripheral
        fWrite('    sFilterConfig.SlaveStartFilterBank = 0;\n', sourceFileHandle) # TODO: Verify this is the correct config
    fWrite('    if(HAL_CAN_ConfigFilter(canHandle, &sFilterConfig) != HAL_OK)', sourceFileHandle)
    fWrite('    {', sourceFileHandle)
    fWrite('      Error_Handler();', sourceFileHandle)
    fWrite('    }', sourceFileHandle)

    i = 1
    for messageGroup in messageGroups:
        i = i + 1
        fWrite('\n    // Filter msgs to the broadcast Id to fifo 0', sourceFileHandle)
        fWrite('    filterID = {msgGrp}<<12;'.format(msgGrp=messageGroup), sourceFileHandle)
        fWrite('    filterID = filterID << 3; // Filter ID is left aligned to 32 bits', sourceFileHandle)
        fWrite('    filterMask = 0xFF00;', sourceFileHandle)
        fWrite('    filterMask = filterMask << 3; // Filter masks are also left aligned to 32 bits', sourceFileHandle)
        fWrite('    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterIdHigh = (filterID>>16) & 0xFFFF;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterIdLow = (filterID & 0xFFFF);', sourceFileHandle)
        fWrite('    sFilterConfig.FilterMaskIdHigh = (filterMask>>16) & 0xFFFF;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterMaskIdLow = (filterMask & 0xFFFF);', sourceFileHandle)
        fWrite('    sFilterConfig.FilterFIFOAssignment = 0;', sourceFileHandle)
        fWrite('    sFilterConfig.FilterActivation = ENABLE;', sourceFileHandle)
        if boardType == 'F0':
            fWrite('    sFilterConfig.BankNumber = {msgGrpNmbr};\n'.format(msgGrpNmbr=i), sourceFileHandle)
            fWrite('    sFilterConfig.FilterNumber = {msgGrpNmbr};\n'.format(msgGrpNmbr=i), sourceFileHandle)
        else:
            fWrite('    sFilterConfig.FilterBank = {msgGrpNmbr};\n'.format(msgGrpNmbr=i), sourceFileHandle)
            # From the reference manual, it seems that setting SlaveStartFilterBank to 0 means all filters are used for the enabled CAN peripheral
            fWrite('    sFilterConfig.SlaveStartFilterBank = 0;\n', sourceFileHandle) # TODO: Verify this is the correct config
        fWrite('    if(HAL_CAN_ConfigFilter(canHandle, &sFilterConfig) != HAL_OK)', sourceFileHandle)
        fWrite('    {', sourceFileHandle)
        fWrite('      Error_Handler();', sourceFileHandle)
        fWrite('    }', sourceFileHandle)

    fWrite('}', sourceFileHandle)

def writeInitFunction(queueInitStrings, sourceFileHandle, headerFileHandle):
    prototype = 'int init_can_driver()'
    fWrite('{prototype};'.format(prototype=prototype), headerFileHandle)
    fWrite('{prototype} {{'.format(prototype=prototype), sourceFileHandle)
    for string in queueInitStrings:
        fWrite('    {string}'.format(string=string), sourceFileHandle)

    fWrite('    generate_CRC_lookup_table();', sourceFileHandle)
    fWrite('}', sourceFileHandle)



def main(argv):
    if argv and len(argv) == 2:
        nodeName = argv[0]
        boardType = argv[1] # F0 or F7
    else:
        print('Error: no target specified or no boardtype specified')
        sys.exit(1)

    print nodeName
    print boardType

    if not (boardType == 'F0' or boardType == 'F7'):
        print("Specifiy either F0 or F7 for boardtype")
        sys.exit(1)

    commonDir = 'common-all'
    genDir = 'Gen'

    genIncDir = os.path.join(genDir, 'Inc')
    genSrcDir = os.path.join(genDir, 'Src')
    create_dir(genIncDir) # Create genIncDir if it doesn't already exist
    create_dir(genSrcDir) # Create genSrcDir if it doesn't already exist

    ScriptsDir = os.path.join(commonDir, 'Scripts')

    depFile = os.path.join(genDir, 'canGen.d')

    dataDir = os.path.join(commonDir, 'Data')
    dbFile = os.path.join(dataDir, '2018CAR.dbc')

    headerFile = os.path.join(genIncDir, nodeName + '_can.h')
    sourceFile = os.path.join(genSrcDir, nodeName + '_can.c')

    db = cantools.db.load_file(dbFile)

    gitCommit = getGitCommit()


    headerFileHandle = open(headerFile, "w+")
    sourceFileHandle = open(sourceFile, "w+")

    writeHeaderFileIncludeGuardAndIncludes(boardType, headerFileHandle, nodeName)


    messageGroups = getNodeAddressAndMessageGroupsAndWriteToHeaderFile(db, nodeName, headerFileHandle)


    writeSourceFileIncludes(nodeName, sourceFileHandle)
    writeDBCVersionAndGitCommitToSourceFile(gitCommit, db, sourceFileHandle)


    (rxMessages, txMessages, normalRxMessages, normalTxMessages, multiplexedRxMessages, multiplexedTxMessages, dtcRxMessages, dtcTxMessages) = parseCanDB(db, nodeName)

    # print normalRxMessages
    writeNormalRxMessages(normalRxMessages, sourceFileHandle, headerFileHandle)

    # print dtcRxMessages
    queueInitStrings = writeDTCRxMessages(dtcRxMessages, sourceFileHandle, headerFileHandle)

    # print multiplexed Rx Messages
    writeMultiplexedRxMessages(multiplexedRxMessages, sourceFileHandle, headerFileHandle)

    # print normal Tx Messages
    writeNormalTxMessages(normalTxMessages, sourceFileHandle, headerFileHandle)

    # print dtc Tx Messages
    writeDTCTxMessages(dtcTxMessages, sourceFileHandle, headerFileHandle)

    # print multiplexed Tx Messages
    writeMultiplexedTxMessages(multiplexedTxMessages, sourceFileHandle, headerFileHandle)

    # print parse can message function
    writeParseCanRxMessageFunction(normalRxMessages, dtcRxMessages, multiplexedRxMessages, sourceFileHandle, headerFileHandle)

    writeSetupCanFilters(boardType, messageGroups, sourceFileHandle, headerFileHandle)

    writeInitFunction(queueInitStrings, sourceFileHandle, headerFileHandle)

    headerFileHandle.close()
    sourceFileHandle.close()


if __name__ == '__main__':
    main(sys.argv[1:])
